function _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest(); }
function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }
function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }
function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i]; return arr2; }
function _iterableToArrayLimit(arr, i) { var _i = null == arr ? null : "undefined" != typeof Symbol && arr[Symbol.iterator] || arr["@@iterator"]; if (null != _i) { var _s, _e, _x, _r, _arr = [], _n = !0, _d = !1; try { if (_x = (_i = _i.call(arr)).next, 0 === i) { if (Object(_i) !== _i) return; _n = !1; } else for (; !(_n = (_s = _x.call(_i)).done) && (_arr.push(_s.value), _arr.length !== i); _n = !0); } catch (err) { _d = !0, _e = err; } finally { try { if (!_n && null != _i.return && (_r = _i.return(), Object(_r) !== _r)) return; } finally { if (_d) throw _e; } } return _arr; } }
function _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }
// Copyright (c) Meta Platforms, Inc. and affiliates.
// All rights reserved.

// This source code is licensed under the license found in the
// LICENSE file in the root directory of this source tree.
import * as d3 from 'd3-contour';
import simplify from 'simplify-js';

// Canvas elements can be created from ImageData
function imageDataToCanvas(imageData) {
  var canvas = document.createElement('canvas');
  var ctx = canvas.getContext('2d');
  canvas.width = imageData.width;
  canvas.height = imageData.height;
  ctx === null || ctx === void 0 ? void 0 : ctx.putImageData(imageData, 0, 0);
  return canvas;
}
export function image2Base64(image) {
  var type = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'image/png';
  var canvas = document.createElement('canvas');
  var ctx = canvas.getContext('2d');
  canvas.width = image.width;
  canvas.height = image.height;
  ctx.drawImage(image, 0, 0, image.width, image.height);
  return canvas.toDataURL(type);
}

// Use a Canvas element to produce an image from ImageData
export function imageDataToImage(imageData) {
  var canvas = imageDataToCanvas(imageData);
  var image = new Image();
  image.src = canvas.toDataURL();
  return image;
}

// Convert the onnx model mask prediction to ImageData
// @ts-ignore
export function arrayToImageData(imageData, input, width, height) {
  var uintImageData = new Uint8ClampedArray(imageData.data); // 转换为 Uint8ClampedArray 类型
  var arr = new Uint8ClampedArray(4 * width * height);
  for (var i = 0; i < input.length; i++) {
    if (input[i] > 0.0) {
      var index = 4 * i;
      arr[index + 0] = uintImageData[index + 0]; // R
      arr[index + 1] = uintImageData[index + 1]; // G
      // TODO 暂时设置不同颜色，期待加描边或者发光
      arr[index + 2] = Math.max(uintImageData[index + 2], 200); // B
      arr[index + 3] = uintImageData[index + 3]; // A
    }
  }

  return imageDataToImage(new ImageData(arr, width, height));
}
function getImageExtent(input, width, height) {
  var pad = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 15;
  var minx = width;
  var maxx = 0;
  var miny = height;
  var maxy = 0;
  for (var i = 0; i < input.length; i++) {
    // Threshold the onnx model mask prediction at 0.0
    // This is equivalent to thresholding the mask using predictor.model.mask_threshold
    // in python

    if (input[i] > 0.0) {
      var x = i % width;
      var y = Math.floor(i / width);
      minx = Math.min(minx, x);
      maxx = Math.max(maxx, x);
      miny = Math.min(miny, y);
      maxy = Math.max(maxy, y);
    }
  }
  return [minx - pad, maxx + pad, miny - pad, maxy + pad];
}
function getImageDataByRegion(minx, miny, maxx, maxy, imageData, width) {
  var data = [];
  var destIndex = 0;
  for (var y = miny; y < maxy; y++) {
    for (var x = minx; x < maxx; x++) {
      var sourceIndex = y * width + x;
      data[destIndex++] = imageData[sourceIndex] > 0 ? 1 : -1;
    }
  }
  return data;
}
export function simplifyLine(points, minX, minY) {
  var tolerance = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 5;
  // 局部坐标转全局坐标
  var pointArray = points.map(function (p) {
    return {
      x: p[0] + minX,
      y: p[1] + minY
    };
  });
  if (tolerance === 0) return pointArray;
  var simplifyData = simplify(pointArray, tolerance, true);
  return simplifyData;
}
export var getBase64 = function getBase64(file) {
  return new Promise(function (resolve, reject) {
    var reader = new FileReader();
    reader.readAsDataURL(file);
    reader.onload = function () {
      return resolve(reader.result);
    };
    reader.onerror = function (error) {
      return reject(error);
    };
  });
};

// Convert the onnx model mask output to an HTMLImageElement
// export function onnxMaskToImage(
//   input: any,
//   width: number,
//   height: number,
// ): any {
//   return imageDataToImage(arrayToImageData(input, width, height));
// }

// 裁剪后的Mask
export function onnxMaskClip(input, width, height) {
  var _getImageExtent = getImageExtent(input, width, height),
    _getImageExtent2 = _slicedToArray(_getImageExtent, 4),
    minx = _getImageExtent2[0],
    maxx = _getImageExtent2[1],
    miny = _getImageExtent2[2],
    maxy = _getImageExtent2[3];
  var bboxData = getImageDataByRegion(minx, miny, maxx, maxy, input, width);
  var imageData = arrayToImageData(bboxData, maxx - minx, maxy - miny);
  return imageDataToImage(imageData);
}
// Mask 转为 矢量多边形
export function onnxMaskToPolygon(input, width, height) {
  var simplifyThreshold = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 5;
  var _getImageExtent3 = getImageExtent(input, width, height),
    _getImageExtent4 = _slicedToArray(_getImageExtent3, 4),
    minx = _getImageExtent4[0],
    maxx = _getImageExtent4[1],
    miny = _getImageExtent4[2],
    maxy = _getImageExtent4[3];
  var bboxData = getImageDataByRegion(minx, miny, maxx, maxy, input, width);
  var bboxWidth = maxx - minx;
  var bboxHeight = maxy - miny;
  var contours = d3.contours().size([bboxWidth, bboxHeight]).smooth(false).thresholds(2);
  var lines = contours(bboxData);
  return simplifyLine(lines[1].coordinates[0][0], minx, miny, simplifyThreshold);
}

// 获取 Mask 后的数据
export function getImageByMask(imageData, input) {
  var flag = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;
  for (var i = 0; i < input.length; i++) {
    // Threshold the onnx model mask prediction at 0.0
    // This is equivalent to thresholding the mask using predictor.model.mask_threshold
    // in python

    if (flag ? input[i] <= 0.0 : input[i] > 0.0) {
      imageData.data[4 * i + 0] = 0;
      imageData.data[4 * i + 1] = 0;
      imageData.data[4 * i + 2] = 0;
      imageData.data[4 * i + 3] = 0;
    }
  }
  return imageDataToImage(imageData);
}
export function getImageByMaskClip(imageData, maskData, width, height) {
  var _getImageExtent5 = getImageExtent(maskData, width, height),
    _getImageExtent6 = _slicedToArray(_getImageExtent5, 4),
    minx = _getImageExtent6[0],
    maxx = _getImageExtent6[1],
    miny = _getImageExtent6[2],
    maxy = _getImageExtent6[3];
  var data = new Uint8ClampedArray(4 * (maxx - minx) * (maxy - miny)).fill(0);
  var destIndex = 0;
  for (var y = miny; y < maxy; y++) {
    for (var x = minx; x < maxx; x++) {
      var sourceIndex = y * width + x;
      if (maskData[sourceIndex] > 0) {
        data[destIndex * 4] = imageData.data[sourceIndex * 4];
        data[destIndex * 4 + 1] = imageData.data[sourceIndex * 4 + 1];
        data[destIndex * 4 + 2] = imageData.data[sourceIndex * 4 + 2];
        data[destIndex * 4 + 3] = imageData.data[sourceIndex * 4 + 3];
      }
      destIndex++;
    }
  }
  var res = new ImageData(data, maxx - minx, maxy - miny);
  return imageDataToImage(res);
}
export function downLoadImage(image) {
  var a = document.createElement('a');
  a.href = image.src;
  a.download = 'image';
  a.click();
}
export function downLoadCanvas(canvas) {
  var a = document.createElement('a');
  a.href = canvas.toDataURL('image/png');
  a.download = 'image';
  a.click();
}

// Image 转 imageData
export function imageToImageData(image) {
  var canvas = document.createElement('canvas');
  var ctx = canvas.getContext('2d');
  canvas.width = image.width;
  canvas.height = image.height;
  ctx === null || ctx === void 0 ? void 0 : ctx.drawImage(image, 0, 0);
  return ctx === null || ctx === void 0 ? void 0 : ctx.getImageData(0, 0, image.width, image.height);
}
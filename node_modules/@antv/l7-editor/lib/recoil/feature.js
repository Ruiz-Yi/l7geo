var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// src/recoil/feature.ts
var feature_exports = {};
__export(feature_exports, {
  default: () => useFeature
});
module.exports = __toCommonJS(feature_exports);
var import_turf = require("@turf/turf");
var import_lodash_es = require("lodash-es");
var import_react = require("react");
var import_react_i18next = require("react-i18next");
var import_recoil = require("recoil");
var import_constants = require("../constants");
var import_utils = require("../utils");
var import_prettier_text = require("../utils/prettier-text");
var import_atomState = require("./atomState");
var import_global = __toESM(require("./global"));
function useFeature() {
  const { baseMap, coordConvert } = (0, import_global.default)();
  const [editorText, setEditorText] = (0, import_recoil.useRecoilState)(import_atomState.editorTextState);
  const [savedText, setSavedText] = (0, import_recoil.useRecoilState)(import_atomState.savedTextState);
  const [features, _setFeatures] = (0, import_recoil.useRecoilState)(import_atomState.featureState);
  const [isDraw, setIsDraw] = (0, import_recoil.useRecoilState)(import_atomState.isDrawState);
  const [scene, setScene] = (0, import_recoil.useRecoilState)(import_atomState.sceneState);
  const { t } = (0, import_react_i18next.useTranslation)();
  const savable = (0, import_react.useMemo)(() => {
    return editorText !== savedText;
  }, [editorText, savedText]);
  const fc = (0, import_react.useMemo)(() => {
    return (0, import_turf.featureCollection)(features);
  }, [features]);
  const setFeatures = (f) => {
    _setFeatures(
      // @ts-ignore
      (0, import_lodash_es.cloneDeep)(f).map((feature, featureIndex) => {
        var _a;
        feature.properties = {
          ...feature.properties,
          [import_constants.FeatureKey.Index]: featureIndex
        };
        if (!((_a = feature.properties) == null ? void 0 : _a[import_constants.FeatureKey.DrawType])) {
          feature.properties[import_constants.FeatureKey.DrawType] = (() => {
            const type = (0, import_turf.getType)(feature);
            if (/Point/.test(type)) {
              return "point";
            }
            if (/LineString/.test(type)) {
              return "line";
            }
            return "polygon";
          })();
        }
        return feature;
      })
    );
  };
  const saveEditorText = (value) => {
    const emptyFeatures = JSON.stringify(
      { type: "FeatureCollection", features: [] },
      null,
      2
    );
    let newFeatures = [];
    if (editorText || value) {
      newFeatures = (0, import_utils.transformFeatures)(value ?? editorText, t);
      if (value) {
        setEditorText(value);
      }
      setSavedText(value ?? editorText);
      setFeatures(newFeatures);
    } else {
      setEditorText(emptyFeatures);
      setSavedText(emptyFeatures);
    }
    return newFeatures;
  };
  const resetFeatures = (newFeatures) => {
    const newText = (0, import_prettier_text.prettierText)({ content: (0, import_turf.featureCollection)(newFeatures) });
    setEditorText(newText);
    setSavedText(newText);
    setFeatures(newFeatures);
  };
  const dataSource = (0, import_react.useMemo)(() => {
    const data = features.map(
      (item, index) => {
        const { properties } = item;
        return { __index: index + 1, ...properties };
      }
    );
    const featureKeyList = [];
    Array.from(
      new Set(
        (0, import_lodash_es.flatMap)(features.map(({ properties }) => Object.keys(properties)))
      )
    ).forEach((field) => {
      const type = typeof data[0][field];
      if (type === "string" || type === "boolean") {
        const value = data.map((item) => String(item[field]));
        featureKeyList.push({ type: "string", field, value });
      } else if (type === "number") {
        const value = data.map((item) => item[field]);
        featureKeyList.push({
          type,
          field,
          min: (0, import_lodash_es.min)(value),
          max: (0, import_lodash_es.max)(value)
        });
      }
    });
    return featureKeyList;
  }, [features]);
  const transformCoord = (0, import_react.useCallback)(
    (newFeatures) => {
      let data = [...newFeatures];
      if (coordConvert === "WGS84" && baseMap === "Gaode") {
        data = data.map((item) => {
          return (0, import_utils.wgs84togcj02)((0, import_lodash_es.cloneDeep)(item));
        });
      } else if (coordConvert === "GCJ02" && baseMap === "Mapbox") {
        data = data.map((item) => {
          return (0, import_utils.gcj02towgs84)((0, import_lodash_es.cloneDeep)(item));
        });
      }
      return data;
    },
    [baseMap, coordConvert]
  );
  const revertCoord = (0, import_react.useCallback)(
    (newFeatures) => {
      let data = [...newFeatures];
      if (coordConvert === "WGS84" && baseMap === "Gaode") {
        data = data.map((item) => {
          return (0, import_utils.gcj02towgs84)((0, import_lodash_es.cloneDeep)(item));
        });
      } else if (coordConvert === "GCJ02" && baseMap === "Mapbox") {
        data = data.map((item) => {
          return (0, import_utils.wgs84togcj02)((0, import_lodash_es.cloneDeep)(item));
        });
      }
      return data;
    },
    [baseMap, coordConvert]
  );
  const bboxAutoFit = (0, import_react.useCallback)(
    (currentFeatures) => {
      const realFeatures = currentFeatures ?? features;
      if (scene && realFeatures.length) {
        const [lng1, lat1, lng2, lat2] = (0, import_turf.bbox)(
          (0, import_turf.featureCollection)(transformCoord(realFeatures))
        );
        scene.fitBounds([
          [lng1, lat1],
          [lng2, lat2]
        ]);
      }
    },
    [features, scene, transformCoord]
  );
  return {
    editorText,
    setEditorText,
    savedText,
    setSavedText,
    features,
    setFeatures,
    savable,
    saveEditorText,
    resetFeatures,
    dataSource,
    bboxAutoFit,
    setIsDraw,
    isDraw,
    scene,
    setScene,
    fc,
    transformCoord,
    revertCoord
  };
}
